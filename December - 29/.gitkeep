import sys

def find_min_cycle(V, edges):
    INF = float('inf')

    # Adjacency matrix for weights
    dist = [[INF] * V for _ in range(V)]
    
    # Initialize distances for edges
    for u, v, w in edges:
        dist[u][v] = w
        dist[v][u] = w

    # Copy of original graph
    best_dist = [row[:] for row in dist]

    min_cycle = INF

    # Floyd-Warshall Variant
    for k in range(V):
        for i in range(k):
            for j in range(i):
                if best_dist[i][j] < INF and dist[i][k] < INF and dist[k][j] < INF:
                    min_cycle = min(min_cycle, best_dist[i][j] + dist[i][k] + dist[k][j])

        # Standard Floyd-Warshall update
        for i in range(V):
            for j in range(V):
                if best_dist[i][k] + best_dist[k][j] < best_dist[i][j]:
                    best_dist[i][j] = best_dist[i][k] + best_dist[k][j]

    return min_cycle if min_cycle != INF else -1


# -------- Input Section --------
V = int(input("Enter number of vertices: "))
E = int(input("Enter number of edges: "))
edges = []

print("Enter edges as: u v w")
for _ in range(E):
    u, v, w = map(int, input().split())
    edges.append([u, v, w])

result = find_min_cycle(V, edges)
print("Minimum Cycle Weight:", result)

